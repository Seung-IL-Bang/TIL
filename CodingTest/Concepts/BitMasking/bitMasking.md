# 비트마스킹(BitMasking)

### Concept

→ 컴퓨터는 내부적으로 모든 데이터를 이진수로 표현한다. 이런 특성을 이용해 정수의 이진수 표현을 자료구조로 사용하는 기법을 **비트 마스킹**이라 한다.  알고리즘이 아닌 bit 를 활용한 테크닉이라고 할 수 있다.

<br>

### Bit

→ 비트는 이진 숫자(Binary digit)를 뜻하고 컴퓨터에서 사용되는 데이터의 최소 단위이다. 비트는 0, 1의 값을 가질 수 있고, true/false 또는 on/off 라는 상태를 나타낸다.

<br>

### 활용

→ 비트마스킹을 이용하면 집합을 효율적으로 표현할 수 있으며, 빠르게 연산을 수행할 수 있다.

**길이가 5인 집합 {0, 1, 2, 3, 4}의 부분집합에 대하여 배열 VS 비트마스킹 표현**

```kotlin
int[] array1 = [1, 1, 1, 1, 0];
int[] array2 = [1, 1, 0, 1, 0];
int[] array3 = [1, 0, 1, 0, 0];
```

```kotlin
{ 0, 1, 2, 3, 4 } => 11111
{ 1, 2, 3, 4 } => 11110
{ 1, 2, 4 } => 10110
{ 2, 4 } => 10100
{ 1 } => 00010
```

위 처럼 배열을 활용하여 부분집합을 구현하면 더 많은 메모리를 차지하며 오버헤드가 증가한다. 반면에, 비트마스킹을 이용하면 더 효율적인 구현이 가능해진다.  부분집합에서 i를 추가하고 싶으면, 단순히 i번째 비트의 값을 1로 변경해주면 된다. 이러한 삽입, 삭제, 조회와 같은 행위는 비트 연산을 통해 쉽게 제어할 수 있다.

<br>

### 장점

1. 수행 시간이 빠르다.
    
    : bit 연산은 대부분 $O(1)$ 으로 빠르게 동작한다.
    
2. 코드가 짧다.
    
    : 다양한 집합 연산들을 비트 연산자 한 줄로 작성할 수 있기 때문에 코드가 간결해진다.
    
3. 메모리 사용량이 더 적다. 
    
    : 적은 bit 수로 많은 경우의 수를 표현 가능하기 때문에 메모리 측면에서 효율적이다. 더 많은 데이터를 미리 계산하고 저장할 수 있는 장점이 있다.(DP에 매우 유용하다.)
    
<br>

### 비트 연산

- AND 연산 (&)
    
    : 대응하는 두 비트가 모두 1일 때, 1 반환.
    
    ```kotlin
    1010 & 1111 = 1010
    ```
    
- OR 연산 ( | )
    
    : 대응하는 두 비트가 하나라도 1일 때, 1 반환.
    
    ```kotlin
    1010 | 1111 = 1111
    ```
    
- XOR 연산 (^)
    
    : 대응하는 두 비트가 서로 다르면 1을 반환.
    
    ```kotlin
    1010 | 1111 = 0101
    ```
    
- NOT 연산 (~)
    
    : 비트의 값을 모두 반전시킨다.
    
    ```kotlin
    ~1010 = 0101
    ```
    
- Left Shift 연산 (<<)
    
    A << B 왼쪽 시프트 연산시 알아둬야 할 사항
    
    1. **결과 값의 크기는 피연산자의 타입에 의해 결정된다.**
    2. 결과 값의 범위 밖으로 넘치는(Overflow) 비트는 소멸, 새로운 비트는 ‘0’으로 채워진다.
    3. 피연산에는 **정수** 형태의 값(byte, int, long)만 사용할 수 있다.
    4. A 타입이 int 또는 long인 경우 A << B의 결과 값은 다음 공식이 성립된다. ⇒ $A * 2^B$

    ```kotlin
    // 1byte 
    01100100 << 2 = 10010000 // 100 << 2 = 144

    // int(= 2byte), 가독성을 위해 _ 사용
    00000000_01100100 << 2 = 00000001_10010000 // 100 << 2 = 400
    ```

- Right Shift 연산 (>>)
    
    A >> B 오른쪽 시프트 연산시 알아둬야 할 사항
    
    1. (int, long) 타입은 최상위 비트가 1이라면 음수(-) 값임을 나타낸다.
    2. 피연산자가 부호를 가지는 (int, long) 타입인 경우 >> 연산 실행 후 최상위 비트는 ‘1’로 채운다.
    3. A 타입이 int 또는 long인 경우 A >> B의 결과 값은 다음 공식이 성립된다. ⇒ $A / 2^B$

    ```kotlin
    // int
    00000000_01100100 >> 2 = 00000000_00011001 // 100 >> 2 = 25

    // signed int
    11111111_10011100 >> 2 = 11111111_11100111 // -100 >> 2 = -25
    ```